function [sigma_mu] = equilibrium_contact_rh(obj, q_0, u_0, N_x, dv,externalWrenches, x)
    options = optimoptions('fmincon', 'MaxFunEvals', 1000);

    u = u_0 + N_x * dv;
    [jointAngles, hessian, lambda, exitflag] = obj.min_potential_energy_conf_const(q_0, u, externalWrenches, [], x, options);
%     % after getting the theta, test contact force
%     [f_c_, ~] = obj.contact_force(jointAngles, u, externalWrenches);
%     f_c_
%     sigma_mu = sqrt(f_c_(1) * f_c_(1) + f_c_(2) * f_c_(2)) / f_c_(3)
    
 
    direction_angle = [cos(beta(1)),cos(beta(2)),cos(beta(3))]';
    [F_e] = obj.compute_external_force(velocity_samples, direction_angle, state);

    Nsample = size(F_e, 2);
    sigma_mu = zeros(1, Nsample);
    
    %get right side of lagrangian equation
    jacobian = contact_jacobian(obj, jointAngles);
    K_theta = -obj.stiffnessMatrix * jointAngles;
    K_theta = repmat(K_theta, [1,Nsample]);
    tau = obj.joint_torques(jointAngles, currents, externalWrenches);
    tau = repmat(tau, [1,Nsample]);
    
    force_ = K_theta + tau - F_e; % should be a 12*n matrix with forces in columns
    
    f_c_0 = pinv(jacobian') * force_; %the contact force
    f_c_1 = f_c_0.^2;
    f_c_1 = sum(f_c_1(1:2,:),1);
    f_c_1 = sqrt(f_c_1);
    
    f_c = f_c_1 ./ f_c_0(3,:);
    
    for i = 1:Nsample
        
        f_c = pinv(jacobian') * (-obj.stiffnessMatrix * jointAngles + ...
            obj.joint_torques(jointAngles, currents, externalWrenches) - F_e);
        sigma_mu(i) = obj.compute_contact_ratio(f_c(:,i));
    end

    v_safe = sigma_mu(sigma_mu <= frictionCoefficient & sigma_mu >= 0 );
    P_s = size(v_safe,2) / Nsample;
    
end


function [J] = contact_jacobian(obj, q)
%
% J = contact_jacobian(q, param)
%
% Calculate the contact Jacobian (generally know as hand Jacobian).
% See Euation 5.14 in [1] for more details.
%
% Input:
% q is the joint angle vector.
%
% Output:
% J is the Hand Jacobian ().
%
    % Get parameters.
    g_sc = obj.surface.tangent_frame(obj.surface.projection(obj.tip_position(q))); % Assume tip is on the surface
    
    g_sf = eye(4);
    p0 = obj.jointPositions;

    % Define wrench basis.
    B_c = [1 0 0; 0 1 0; 0 0 1; zeros(3)];

    % Initialize Jacobian from base to tip frame.
    J_sf = zeros(6, 3 * obj.numJoints);

    % Calculate the finger Jacobian.
    for n = 1:1:obj.numJoints
        w = q(3 * n - 2 : 3 * n);
        p = [0; 0; p0(1, n)];
        g = se3rot(w, p, 1);

        % Calculate the twists analytically.
        [w1, w2, w3] = obj.velocity_axes(w);
        xi1 = twistr(w1, p);
        xi2 = twistr(w2, p);
        xi3 = twistr(w3, p);

        % Calculate the finer Jacobian.
        J_sf(:, 3 * n - 2) = adj(g_sf) * xi1;
        J_sf(:, 3 * n - 1) = adj(g_sf) * xi2;
        J_sf(:, 3 * n) = adj(g_sf)* xi3;
        g_sf = g_sf * g;
    end

    % Assemble the contact (or hand) Jacobian eq5.14 MLS
    J = B_c' * adjinv(g_sc) * J_sf;

end
